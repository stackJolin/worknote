## 重新理解线程和队列的关系

-------

一个队列是有一个或多个任务组成的，这些任务要被执行的时候，系统会把他们分配到某个线程上去执行。在`多核`架构中，多核会将多个线程分配到不同的`核`上去执行。

所以，对于`核`来讲，并没有`任务`的概念，只有`线程`的概念；对于队列来讲，并没有`线程`的概念，只有`任务`的概念

而对于一个`并发队列`来讲，其中的任务会被操作系统分配到多个`线程`中去执行，即这个`并发`队列可能对应多个线程；对于一个`串行队列`来讲，他每次对应一个`线程`,这个线程可能不变，也可能会改变

每一个时刻，一个线程只能执行一个任务。一个线程可能被挂起或闲置，因此，线程存在时，不一定在执行任务，也就是不一定在消耗`CPU`

队列和线程是两个层级的概念，队列是为了方便使用和理解的抽象结构，而线程是系统调度的单位。他们不是附属关系，而是上下层的关系

当我们同步的提交一个任务时，首先会阻塞当前队列，然后等到下一次 runloop 时再在合适的线程中执行 block。在执行 block 之前，首先会寻找合适的线程来执行block，然后阻塞这个线程，直到 block 执行完毕。寻找线程的规则是: **任何提交到主队列的 block 都会在主线程中执行**，在不违背此规则的前提下，文档还告诉我们系统会自动进行优化，**尽可能的在当前线程执行 block**。



如果一个API调用任务在非主队列上的主线程中被执行，会导致某些依赖主队列运行的库出现问题（如VectorKit）。



<font color='red'>主队列中的任务，一定是运行在主线程中；但是主线程执行的任务，不一定都是主队列上的，因为：`系统在调度任务的时候，会进行优化，会尽可能的在当前线程执行block`，也就是说，虽然当前的代码是工作在主线程，但是当前的队列很有可能不是主队列。这就会导致一个问题，有的库在低层逻辑做判断的时候，判断的是当前的队列是否是主队列，而不是判断的是当前线程是不是主线程，从而导致crash。如果当前队列是主队列，那么当前的线程一定是主线程，反过来，则不一定</font>



#### 主线程有多个队列，并不是只有一个队列

--------



#### 主线程执行的代码，很可能不是在主队列中

------





#### 主队列中的任务，一定是工作在主线程中

--------

