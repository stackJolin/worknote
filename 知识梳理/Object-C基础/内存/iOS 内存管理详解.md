## iOS内存管理详解



#### iOS内存布局

-----

从<font color="red">高地址</font>到<font color='red'>低地址</font> 依次为:

- 栈区

  ````
  存放的内容：函数的参数和局部变量
  特点：先进后出
  栈地址从高到低分配
  系统编译器管理
  ````

- 堆区

  ```
  程序员管理
  ARC下，是通过编译器的时候自动添加retain、release、autorelease
  堆区的地址，是从高到低
  手机上所有的App共用的区域，内存分配由系统负责
  ```

- 全局区/静态区

  ```
  存放全局变量和静态变量
  包括两个部分：未初始化的 和 初始化过的
  全局区/静态区在内存是存在放一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域
  ```

- 常量区

  ```
  存放常量字符串
  ```

- 代码区

  ```
  存放App的二进制代码
  ```



###### 其他

```
系统通过一个链表来记录堆区内存的分配情况
```

```
系统使用一个链表来维护所有已经分配的内存空间（系统仅仅纪录，并不管理具体的内容）
```

```
变量使用结束后，需要释放内存，OC中是根据引用计数是否为0时，为0就说明没有任何变量使用该空间，那么系统将直接收回。
```

```
当一个app启动后，代码区，常量区，全局区大小已固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这两个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错）。
```

```
操作系统使用stack段中的指针值访问heap段中的对象。如果stack对象的指针没有了，则heap中的对象就不能访问。这也是内存泄露的原因。
```



#### iOS内存管理

----

iOS开发中，内存中的对象主要有两类，一类是值类型，比如int、float、struct等基本数据类型，另一类是引用类型，也就是继承自NSObject类的所有的OC对象。

值类型会被放入栈中，依次紧密排列，在内存中占有一块连续的内存空间，遵循先进后出的原则。

引用类型会被放到堆中，当给对象分配内存空间时，会随机的从内存当中开辟空间，对象与对象之间可能会留有不确定大小的空白空间，因此会产生很多内存碎片，需要我们管理。

栈内存与堆内存从性能上比较，栈内存要优于堆内存，这是因为栈遵循先进后出的原则，因此当数据量过大时，存入栈会明显的降低性能。因此，我们会把大量的数据存入堆中，然后栈中存放堆的地址，当需要调用数据时，就可以快速的通过栈内的地址找到堆中的数据。

<font color='red'>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</font>



#### 散列表内存管理方案

----



#### weak弱引用管理

------





#### AutoReleasePool

-----



#### iOS中的循环引用

-----



#### NSTimer引起的循环引用

-----

