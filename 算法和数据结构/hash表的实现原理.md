## 哈希表的实现原理

-------

`哈希表`也叫散列表。本质上他是一个`数组`。



#### `hash`表的存储过程

---------

- 使用`hash`函数根据`key`得到哈希值`h`
- 如果数组的大小为n，那么`key`对应的`value`，所在数组的`下标`，就是`h % n`
- 如果`h % n`下标所在箱子中，已经存在`value`，出现了`hash`冲突，此时需要用`拉线法`或`线性探测法`解决冲突



#### 常用的哈希函数

-------

哈希查找的第一步就是使用`哈希函数`，将`键值`映射成`索引`。这种`映射函数`就是`哈希函数`

这个`哈希函数`可以将`key`映射到某个范围中，比如数组下标[0...N]。

一个优秀的`哈希算法`有以下几点要求：

```objective-c
-	不可逆。只能通过key推导hash值，不能由hash值去推导key
- 敏感性。不同key的任何不同，哪怕这个不同只差一个字，经过`hash`函数，得到的hash值也会有很大的不同
- 冲突概率低。对于不同的key，存在不同key，而hash值一样的情况很小
- 算法的效率高
```



#### 负载因子 = 总键值对数 / 数组的个数

---------









#### hash冲突解决办法一 - 拉链法

--------

简单来说就是`数组` + `链表`的一个数据结构





#### hash冲突解决办法二 - 开放地址法

-------

开放地址法又分为三种：

- 线性探测
- 二测探测
- 再哈希法



###### 线性探测







#### 拉链法和开放地址法的对比

---------

拉链法的优点:

```markdown
-	拉链法处理冲突接单，没有`堆积现象`
- 拉链法中各个链表的节点空间是动态的，更适合表长度无法确定的情况
```

拉链法的缺点

```markdown
指针需要额外的空间，故当结点规模较小时，开放定址线性探测发较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址线性探测发中的冲突，从而提高平均查找速度。
```

开放定址线性探测法缺点：

```markdown
-	容易产生堆积问题
- 不适合大规模存储
- 对散列函数要求更高
- 会出现多次冲突的现象
- 节点规模很大的时候，浪费很多空间
```





#### `hash`表的平均查找长度

------









